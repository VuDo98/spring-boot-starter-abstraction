package io.github.voduku.springdoc;

import static org.springframework.util.MimeTypeUtils.APPLICATION_JSON_VALUE;

import io.github.voduku.controller.AbstractController;
import io.github.voduku.model.AbstractEntity;
import io.github.voduku.model.AbstractSearch;
import io.github.voduku.model.AbstractSearch.Fields;
import io.github.voduku.model.criteria.DateCriteria;
import io.github.voduku.model.criteria.DecimalCriteria;
import io.github.voduku.model.criteria.NumberCriteria;
import io.github.voduku.model.criteria.StringCriteria;
import io.swagger.v3.oas.models.Operation;
import io.swagger.v3.oas.models.media.IntegerSchema;
import io.swagger.v3.oas.models.media.NumberSchema;
import io.swagger.v3.oas.models.media.Schema;
import io.swagger.v3.oas.models.media.StringSchema;
import io.swagger.v3.oas.models.parameters.Parameter;
import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import lombok.RequiredArgsConstructor;
import lombok.SneakyThrows;
import org.springdoc.core.customizers.OperationCustomizer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.Bean;
import org.springframework.core.MethodParameter;
import org.springframework.util.CollectionUtils;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.method.HandlerMethod;

/**
 * @author VuDo
 * @since 4/20/2021
 */
@RequiredArgsConstructor
public abstract class SpringdocConfig {

  private static final List<String> EXPLICIT_SEARCH_PARAMETERS = List.of(Fields.includes.name(), Fields.excludes.name());
  private static final Set<String> AVAILABLE_METADATA = Arrays.stream(AbstractEntity.Fields.values()).map(Enum::name).collect(Collectors.toSet());
  private static final List<String> OPERATIONS_TO_BE_FILTERED = List.of("getCustom", "getSlice", "getPage");
  private static final String DOT = ".";
  private static final String EQUAL = DOT + "eq";
  private static final String ID = "id";
  private static final String QUERY = "query";
  private static final String CUSTOM = "Custom";
  private static final String REQUEST = "request";
  private static final List<Class<?>> unparsableIdTypes = List.of(
      Boolean.TYPE, boolean.class,
      Character.TYPE, Character[].class, CharSequence.class, char.class, char[].class, String.class,
      byte.class, short.class, int.class, long.class, float.class, double.class,
      Byte.TYPE, Short.TYPE, Integer.TYPE, Long.TYPE, Float.TYPE, Double.TYPE);

  @Autowired(required = false)
  private ApplicationContext context;

  @Bean
  public OperationCustomizer customizer() {
    return (op, handlerMethod) -> {
      if (op.getParameters() == null) {
        op.setParameters(new ArrayList<>());
      }
      boolean isAutoGeneratedKey = ((AbstractController<?, ?, ?, ?>) context.getBean((String) handlerMethod.getBean())).getService().isAutoGeneratedKey();
      if (Arrays.stream(handlerMethod.getMethodParameters()).anyMatch(param -> unparsableIdTypes.contains(param.getParameterType())) && !isAutoGeneratedKey) {
        var schema = getSchema(handlerMethod.getMethodParameters()[0].getParameterType());
        op.getParameters().add(0, new Parameter().name(ID).in(QUERY).required(true).schema(schema));
      }
      customizePostCreate(op, handlerMethod);
      customizeCriteria(op, handlerMethod);
      op.getParameters().stream().filter(parameter -> EXPLICIT_SEARCH_PARAMETERS.contains(parameter.getName()))
          .forEach(parameter -> setEnumForParameter(parameter, handlerMethod));
      return op;
    };
  }

  @SuppressWarnings("all")
  private void customizePostCreate(Operation operation, HandlerMethod handlerMethod) {
    PostMapping annotation = handlerMethod.getMethod().getAnnotation(PostMapping.class);
    if (annotation == null
        || annotation.path() == null
        || Arrays.stream(annotation.path()).anyMatch(path -> !Objects.equals(path, "/"))
        || annotation.value() == null
        || Arrays.stream(annotation.value()).anyMatch(path -> !Objects.equals(path, "/"))
    ) {
      return;
    }

    Schema<?> requestBody = operation.getRequestBody().getContent().get(APPLICATION_JSON_VALUE).getSchema();
    Map<String, Schema> props = requestBody.getProperties();

    if (!CollectionUtils.isEmpty(operation.getParameters())
        && operation.getParameters().size() == 1
        && unparsableIdTypes.contains(handlerMethod.getMethodParameters()[0].getParameterType())
        || props != null && props.containsKey(ID)
    ) {

      props.remove(ID);
      if (props.get(REQUEST) != null) {
        requestBody.set$ref(props.get(REQUEST).get$ref());
        requestBody.getProperties().remove(REQUEST);
      }
    }
  }

  private void setEnumForParameter(Parameter parameter, HandlerMethod handlerMethod) {
    Arrays.stream(handlerMethod.getMethodParameters())
        .filter(methodParameter -> AbstractSearch.class.isAssignableFrom(methodParameter.getParameterType()))
        .findFirst()
        .map(this::getEnums)
        .ifPresent(enums -> parameter.setDescription("Available values to be " + parameter.getName().replace("s", "d")
            + ": " + Stream.concat(enums.stream(), AVAILABLE_METADATA.stream()).distinct().collect(Collectors.joining(", "))));
  }

  @SuppressWarnings("unchecked")
  private Set<String> getEnums(MethodParameter param) {
    Class<Enum<?>> c = (Class<Enum<?>>) ((ParameterizedType) param.getParameterType().getGenericSuperclass()).getActualTypeArguments()[0];
    return Arrays.stream(c.getEnumConstants()).map(Enum::name).collect(Collectors.toCollection(LinkedHashSet::new));
  }

  private void customizeCriteria(Operation operation, HandlerMethod handlerMethod) {
    if (OPERATIONS_TO_BE_FILTERED.stream().noneMatch(operation.getOperationId()::contains)) {
      return;
    }
    if (operation.getOperationId().contains(CUSTOM)) {
      operation.getParameters().removeIf(param -> param.getName().contains(DOT));
      return;
    }
    var fieldSchemas = Arrays.stream(handlerMethod.getMethodParameters())
        .map(MethodParameter::getParameterType)
        .filter(AbstractSearch.class::isAssignableFrom)
        .map(Class::getDeclaredFields)
        .flatMap(Arrays::stream)
        .collect(Collectors.toMap(Field::getName, this::getSchema));

    var paramNames = new HashSet<>();
    List<Parameter> toBeRemoved = new ArrayList<>();
    var operationParameters = operation.getParameters();
    operationParameters.forEach(param -> {
      String name = param.getName().split("\\.")[0];
      if (!param.getName().contains(DOT)) {
        return;
      }
      if (paramNames.contains(name)) {
        toBeRemoved.add(param);
        return;
      }
      paramNames.add(name);
      Schema<?> schema = fieldSchemas.get(name);
      param.name(name + EQUAL).schema(schema).description(getDescription(schema));
    });
    operationParameters.removeAll(toBeRemoved);
  }

  @SneakyThrows
  private Schema<?> getSchema(Field field) {
    if (field.getType().equals(StringCriteria.class)) {
      return new StringSchema();
    }
    if (field.getType().equals(DecimalCriteria.class)) {
      return new NumberSchema().format("decimal");
    }
    if (field.getType().equals(NumberCriteria.class) || field.getType().equals(DateCriteria.class)) {
      return new IntegerSchema().format("int64");
    }
    throw new UnsupportedOperationException("Field type in search class be a XCriteria type. Ex: StringCriteria");
  }

  private String getDescription(Schema<?> schema) {
    if (schema instanceof StringSchema) {
      return "You can use .eq, .in, .isNull or .like with corresponding data type and sql semantic to apply filtering";
    }
    if (schema instanceof NumberSchema || schema instanceof IntegerSchema) {
      return "You can use .eq, .in, .isNull, .gt, .lt, .gte, .lte with corresponding data type and sql semantic to apply filtering";
    }
    return null;
  }

  private Schema<?> getSchema(Class<?> clazz) {
    if (clazz == null) {
      throw new IllegalArgumentException("Schema class must not be null");
    } else if (clazz == String.class) {
      return new Schema<String>();
    } else if (clazz == Long.class) {
      return new Schema<Long>();
    } else {
      return new Schema<>();
    }
  }
}
